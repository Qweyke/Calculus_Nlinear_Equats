"""
Суть метода простейших итераций основана на принципе сжимающего отображения:
    Идея метода простой итерации состоит в том, чтобы уравнение f(x) = 0 привести к эквивалентному уравнению x = phi(x)
    далее строить итерации по принципу x_(n+1) = phi(x_n). Изначально задаем приближенно значение x_0 = (a+b)/2.

Функция phi(x) должна быть непрерывна на отрезке [a, b]
Функция phi(x) должна быть сжимающейся на отрезке [a, b], то есть существует const: 0 < const < 1,
что |phi'(x)| <= const на[a, b]

Можно задать погрешность eps, при достижении который абсолютная разность текущего x_n и предыдущего x_n-1
|(x_n) - (x_n-1)| становится меньше eps |(x_n) - (x_n-1)| < eps, тогда цикл останавливается.
"""

from math import *

a = 0  # начало отрезка
b = 1  # конец отрезка
eps = 10**(-6)  # погрешность


def f(x):  # функция
    return (0.75-x)*(exp(1)**(x/2)) - 0.5


def phi(x):  # преобразованная функция
    return 0.75 - 0.5 * exp(1)**(-x/2)


def d_phi(x):  # производная преобразованной функции
    return 0.25 * exp(1)**(-x/2)


def solve1(d_func, func, f_func, x0, x1):

    if abs(d_func(x0)) < 1 or abs(d_func(x1)) < 1:  # проверка условия сжимаемости
        cnt = 0
        curr_x = (x0+x1) / 2
        prev_x = 0
        while abs(curr_x - prev_x) > eps:
            prev_x = curr_x
            curr_x = func(curr_x)
            cnt += 1

        print(f"Кол-во итераций (метод простых итераций) = {cnt}")
        print(f"Корень методом простых итераций: {round(curr_x, 5)}")   # вывод округления x до 5 знаков
        res = round(curr_x, 5)
        return round(abs((f_func(res) / eps)), 5)  # подстановка x в изначальную функцию, без 10^(-p)

    else:
        return None  # метка ошибки


if __name__ == "__main__":
    print(solve1(d_phi, phi, f, a, b))
