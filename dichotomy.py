"""
Суть метода бисекции или дихотомии:
    Необходимо выбрать отрезок значений [a, b] хотя бы с 1 корнем, удовлетворяющим условиям f(x) = 0
    Далее проводим проверку, если f(a) * f(b) = 0, значит один из концов является корнем, находим его
    Если нет, то начинаем цикл деления отрезка на половины, пока разница между концами больше заданной погрешности eps
вычисляем корни по принципу (a+b) / 2:
        Если f(a) * f((a+b) / 2) < 0, то корень в этом отрезке, b = (a+b) / 2, идем дальше, пока погрешность позволяет
        Если f(a) * f((a+b) / 2) > 0, то корень в отрезке [((a+b) / 2), b], a = (a+b) / 2
    После чего выводим |f((a+b)/2)| - значение функции в погрешности, корень x = (a+b) / 2 найден
"""
import math

a = 0  # начало отрезка
b = 1  # конец отрезка
eps = 10**(-6)  # погрешность


def f(x):
    return (0.75-x)*(math.exp(1)**(x/2)) - 0.5


def solve(func, x0, x1, epsilon):
    count = 0
    if func(x0) * func(x1) == 0:  # уже есть нулевое зн функции
        if func(x0) == 0:
            return x0
        else:
            return x1

    elif func(x0) * func(x1) < 0:  # f(x) на концах имеют разные знаки
        # while abs(func((x1 - x0)/2)) > epsilon:
        while abs(x1 - x0) > epsilon:
            count += 1
            mid = (x0 + x1) / 2
            if func(x0) * func(mid) < 0:
                x1 = mid
                # print(f" x1: {x1} ")

            elif func(x0) * func(mid) > 0:
                x0 = mid
                # print(f" x0: {x0} ")
            else:
                break

        # print(x0, x1)
        print(f"Кол-во итераций методом бисецкии = {count}")
        print(f"Корень методом бисекции = {(x1 + x0) / 2:.5f}")
        res = round((x1 + x0) / 2, 5)  # округление до 5 знаков после зап

        return round(abs((func(res) / eps)), 5)  # значение без 10^(-p), округление до 5 знаков


if __name__ == "__main__":
    print(f"Значение функции при x: {solve(f, a, b, eps)} * 10^(-6)")
